# Solution to Jane Street Puzzle 2022 July  "Andy's Morning Stroll"

import numpy as np
# We consider a Markov Process with state 0, ..., 5, where state i is i steps away from origin
# by letting T_i := E[time to origin|s_0 = i] for i > 0, we have a linear system T = PT + 1. 
P = np.array([
    [0, 1, 0, 0, 0, 0],
    [0, 0, 2/3, 0, 0, 0],
    [0, 1/3, 1/3, 1/3, 0, 0],
    [0, 0, 1/3, 1/3, 1/3, 0],
    [0, 0, 0, 2/3, 0, 1/3],
    [0, 0, 0, 0, 1, 0],
])
T_1_to_5 = np.linalg.solve(np.eye(5) - P[1:, 1:], np.ones(5))
T_0 = T_1_to_5[0] + 1
print(f"T_0: {T_0}")  # T_0 = 20

# X[n]: The number of paths that returns to the origin at time 2n
# Y[n]: The number of paths that returns to the origin for the first time at time 2n
# Y[n] = X[n] - sum{Y[k] * X[n - k]: k = 1, ..., n - 1}

# How to calculate X[n]? 
# even steps and odd steps share the same direction
# the sum of the step direction must be zero vector,
# which implies that the number of the opposite directions pairs (3 types of them) are the same.
# Therefore X[n] = sum{n! / (n_1! n_2! n_3!): n_1 + n_2 + n_3 = n}

f = 1
factorial = [1] + [f := f * i for i in range(1, 11)]

def compute_X(n):
    ret = 0
    for n_1 in range(0, n + 1):
        for n_2 in range(0, n - n_1 + 1):
            n_3 = n - n_1 - n_2
            ret += (factorial[n] // (factorial[n_1] * factorial[n_2] * factorial[n_3])) ** 2
    return ret

X = [compute_X(i) for i in range(11)]
Y = [0] * 11
for n in range(1, 11):
    Y[n] = X[n] - sum([Y[k] * X[n - k] for k in range(1, n)])

print(X)
print(Y)

q = [Y[n] / 3 ** (2 * n) for n in range(1, 11)]  # Probability of returning to origin by time 20
p = 1 - q

print(f"Prob[T > 20] = {1 - Y[] / 3 ** 20


